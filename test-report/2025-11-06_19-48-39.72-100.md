# QUALITATIVE TEST ANALYSIS REPORT: GitOps Package

**Generated:** 2025-11-06 19:48:39
**Analyst:** Senior Test Architect (AI)
**Package:** @kodebase/git-ops
**Test Runner:** Vitest 2.x

---

## A) EXECUTIVE SUMMARY

### Overall Score: **72/100** (B-)

**Weighted Breakdown:**
- Behavioral Depth: 18/25 (72%)
- Isolation & Determinism: 9/15 (60%)
- Brittleness Risk: 11/15 (73%)
- Risk Alignment: 11/15 (73%)
- Signal Density: 11/15 (73%)
- Structure & Readability: 8/10 (80%)
- Execution Health: 2/3 (67%)
- Tooling Hygiene: 2/2 (100%)

### Key Metrics
- **Test Files:** 24
- **Test LOC:** ~10,000 lines
- **Coverage:** Lines 90%, Functions 95%, Branches 80%, Statements 90%
- **Mutation Score:** Not configured (major gap)
- **Mock Ratio:** ~0.45 (108 mocks / ~240 tests) - **HIGH**
- **Assertion Density:** ~2.5 assertions/test - **GOOD**
- **Focused/Skipped Tests:** 2 files with `.only` or `.skip` - **NEEDS CLEANUP**

### Top 5 Risks

1. **No Mutation Testing** - High coverage (90%) but unknown quality. Likely shallow assertions surviving mutations.
2. **Over-Mocking Implementation Details** - 45% mock ratio with extensive `vi.spyOn` on private methods (`executeWithTimeout`, internal state).
3. **No Timer/RNG Control** - Tests use real time and randomness, risking flakiness and non-determinism.
4. **Git Command Testing Brittleness** - Heavy reliance on real git operations in integration tests; fragile to environment changes.
5. **Hot & Cold Spots** - Recent massive churn (10k+ LOC added in Nov 2025) in orchestration/strategy modules with integration-heavy tests that are slow to evolve.

### Top 5 Quick Wins

1. **Add Stryker mutation testing** - Copy-paste config below, run, identify weak assertions.
2. **Inject Clock & RNG** - Add `test/setup.ts` with `vi.useFakeTimers()` and `Math.random` mock.
3. **Remove `.only`/`.skip`** - Clean up 2 flagged files ([hook-installer.test.ts:50](src/hooks/core/hook-installer.test.ts#L50), [pre-push-validator.test.ts](src/hooks/validation/pre-push-validator.test.ts)).
4. **Add ESLint rules** - Ban focused tests, real I/O in unit tests, weak assertions (`toBeDefined` without semantic check).
5. **Extract Test Builders** - Replace repeated 50+ line `beforeEach` blocks with domain builders (`ArtifactBuilder`, `MergeMetadataBuilder`).

### 30/60/90 Day Plan

**30 Days (Foundation):**
- ‚úÖ Install Stryker, run baseline mutation report
- ‚úÖ Add fake timers/RNG in test setup
- ‚úÖ Clean `.only`/`.skip` tests
- ‚úÖ Add ESLint `no-only-tests`, `no-restricted-imports` (fs, fetch)
- ‚úÖ Rewrite 10 weakest tests (see Section C)
- **Exit Criteria:** Mutation score ‚â•70%, no flaky tests in CI

**60 Days (Architecture):**
- ‚úÖ Create contract suites for 3 seams: `GitPlatformAdapter`, `HookExecutor`, `DetectorService`
- ‚úÖ Add property tests for pure functions: artifact ID extraction, branch validation, cascade logic
- ‚úÖ Build test data builders (`MergeMetadataBuilder`, `OrchestrationResultBuilder`)
- **Exit Criteria:** Contract tests run against real & fake adapters; property tests cover 5+ invariants

**90 Days (Culture & Gates):**
- ‚úÖ CI gates: diff coverage ‚â•80%, mutation score ‚â•75% (core modules ‚â•85%)
- ‚úÖ Flake budget policy: <2% failure rate, auto-quarantine flaky tests
- ‚úÖ Remove git integration tests or move to separate `e2e/` suite
- ‚úÖ Document test philosophy: "Test invariants, not implementation"
- **Exit Criteria:** Zero `.only`/`.skip` in main; <5% mock ratio in unit tests; mutation score ‚â•80%

---

## B) SCORECARDS (Per Module)

### 1. Core Hook System ([src/hooks/core/](src/hooks/core/))
**Files:** hook-executor, hook-logger, idempotency-tracker, hook-installer
**Overall Grade:** B+ (82/100)

| Dimension | Score | Justification |
|-----------|-------|---------------|
| Behavioral | 4/5 | Tests encode domain concepts (idempotency, lifecycle callbacks, timeouts) but over-mock internals |
| Isolation | 3/5 | Mocks `executeWithTimeout` private method; no fake timers for timeout tests |
| Brittleness | 4/5 | Good: tests behavior over implementation. Bad: tight coupling to internal structure via type casting |
| Structure | 4/5 | Clear AAA, descriptive names. Bloated `beforeEach` (50+ lines) |
| Signal | 3/5 | High assertion count but shallow (`toBeDefined`, `toBeGreaterThanOrEqual(0)` without semantic meaning) |

**Best Example:** [hook-executor.test.ts:229-245](src/hooks/core/hook-executor.test.ts#L229-L245) - "calls all lifecycle hooks in correct order" encodes temporal invariant with explicit ordering check.

**Worst Example:** [hook-executor.test.ts:58-64](src/hooks/core/hook-executor.test.ts#L58-L64) - "executes hook successfully" has zero semantic assertions, just `success === true`.

**Action:** Add property test: "Any hook execution measures non-negative duration", "Lifecycle callbacks never reorder".

---

### 2. Orchestration Layer ([src/hooks/orchestration/](src/hooks/orchestration/))
**Files:** strategy-executor, post-merge-orchestrator, post-checkout-orchestrator
**Overall Grade:** C+ (68/100)

| Dimension | Score | Justification |
|-----------|-------|---------------|
| Behavioral | 3/5 | Tests workflows but relies heavily on mocked git commands, obscuring actual logic |
| Isolation | 2/5 | **CRITICAL:** Mocks `execAsync` for every git command. Real logic never tested. |
| Brittleness | 2/5 | Extremely brittle: 40+ lines of mock setup per test. Changes to git command order break tests. |
| Structure | 3/5 | Clear describe blocks, but tests are 50+ lines with complex mock orchestration |
| Signal | 3/5 | Good coverage of edge cases (PR creation failure, auto-merge failure) but assertions on mocks, not state |

**Best Example:** [strategy-executor.test.ts:129-145](src/hooks/orchestration/strategy-executor.test.ts#L129-L145) - "no changes scenario" tests empty-result invariant without mocks.

**Worst Example:** [strategy-executor.test.ts:186-209](src/hooks/orchestration/strategy-executor.test.ts#L186-L209) - 6-deep mock chain (git log ‚Üí checkout ‚Üí add ‚Üí commit ‚Üí rev-parse ‚Üí push) tests nothing about domain logic.

**Action:** Extract `FakeGitAdapter` with in-memory state. Test strategy logic against fake, not mocks.

---

### 3. Detection & Validation ([src/hooks/detection/](src/hooks/detection/), [src/hooks/validation/](src/hooks/validation/))
**Files:** post-merge-detector, post-checkout-detector, branch-validator, pre-push-validator
**Overall Grade:** B (76/100)

| Dimension | Score | Justification |
|-----------|-------|---------------|
| Behavioral | 4/5 | Excellent: tests domain rules (artifact ID extraction, branch patterns, PR detection) |
| Isolation | 4/5 | Uses real git in temp dirs (appropriate for detectors). Pure validators have zero I/O. |
| Brittleness | 4/5 | Robust: tests multiple naming conventions, edge cases, invalid inputs |
| Structure | 5/5 | **EXEMPLARY:** Helper functions, clear AAA, one assertion per invariant |
| Signal | 4/5 | Strong: tests semantic properties (sorted IDs, deduplication, regex edge cases) |

**Best Example:** [branch-validator.test.ts:73-128](src/hooks/validation/branch-validator.test.ts#L73-L128) - Comprehensive regex testing with positive/negative cases, edge inputs.

**Worst Example:** None significant. This module is the strongest.

**Action:** Add property test: "Any valid artifact ID extracted from branch name should exist in filesystem" (finds regression where validator accepts IDs but loader fails).

---

### 4. Integration Tests ([src/hooks/core/hook-system.integration.test.ts](src/hooks/core/hook-system.integration.test.ts), [src/integration.test.ts](src/integration.test.ts))
**Overall Grade:** C (60/100)

| Dimension | Score | Justification |
|-----------|-------|---------------|
| Behavioral | 4/5 | Tests end-to-end workflows (good for confidence) |
| Isolation | 1/5 | **CRITICAL:** Requires real git, gh CLI, network. Non-deterministic. |
| Brittleness | 2/5 | Extremely fragile: breaks on missing gh auth, git config, network timeouts |
| Structure | 3/5 | Clear scenarios but tests are 100+ lines |
| Execution | 1/5 | Slow (5-10s per test), flaky (depends on external state) |

**Action:** Move to `e2e/` directory, run separately in CI. Replace with contract tests for adapters.

---

## C) TOP 10 CONCRETE REWRITES

### 1. **Shallow Success Check ‚Üí Invariant Test**

**Invariant:** Hook execution always measures a non-negative duration and returns a result with all required fields.

**Current (hook-executor.test.ts:58-64):**
```typescript
it("executes hook successfully with default config", async () => {
  const result = await executor.executeHook("post-merge", mockContext);

  expect(result.success).toBe(true);
  expect(result.duration).toBeGreaterThanOrEqual(0);
  expect(result.error).toBeUndefined();
});
```

**Problem:** Tests nothing about actual behavior. Empty hook implementation would pass.

**Rewritten:**
```typescript
it("successful execution returns complete result with non-negative duration", async () => {
  const result = await executor.executeHook("post-merge", mockContext);

  // Invariant: All results have these properties
  expect(result).toMatchObject({
    success: expect.any(Boolean),
    duration: expect.any(Number),
    stdout: expect.any(String),
    stderr: expect.any(String),
  });
  expect(result.duration).toBeGreaterThanOrEqual(0);

  // Semantic: Success means no error
  if (result.success) {
    expect(result.error).toBeUndefined();
  } else {
    expect(result.error).toBeDefined();
  }
});
```

---

### 2. **Over-Mocked Private Method ‚Üí Fake Adapter**

**Invariant:** Strategy executor creates cascade commits only when artifacts have been updated.

**Current (strategy-executor.test.ts:186-234):**
```typescript
it("should create cascade PR successfully", async () => {
  // 7 chained execAsync mocks
  execAsyncMock
    .mockResolvedValueOnce({ stdout: "Merge pull request #42", exitCode: 0 })
    .mockResolvedValueOnce({ stdout: "", exitCode: 0 })
    .mockResolvedValueOnce({ stdout: "", exitCode: 0 })
    // ... 4 more

  vi.mocked(mockAdapter.createPR).mockResolvedValueOnce(mockPRInfo);

  const result = await executor.execute({ strategy: "cascade_pr", cascadeResults });

  expect(result.success).toBe(true);
  expect(result.prInfo?.number).toBe(43);
});
```

**Problem:** Tests mock orchestration, not strategy logic. Real git behavior never verified.

**Rewritten:**
```typescript
class FakeGitAdapter {
  branches: Map<string, string[]> = new Map(); // branch ‚Üí commits
  prs: PRInfo[] = [];

  async checkout(branch: string) { /* update state */ }
  async commit(message: string) { this.branches.get(current).push(message); }
  async createPR(opts): Promise<PRInfo> {
    const pr = { number: this.prs.length + 1, ...opts };
    this.prs.push(pr);
    return pr;
  }
}

it("creates cascade PR only when artifacts updated", async () => {
  const fakeGit = new FakeGitAdapter();
  const executor = new StrategyExecutor(config, fakeGit);

  // Empty cascade
  const emptyResult = await executor.execute({
    strategy: "cascade_pr",
    cascadeResults: { totalArtifactsUpdated: 0 }
  });
  expect(fakeGit.prs).toHaveLength(0);

  // Non-empty cascade
  const result = await executor.execute({
    strategy: "cascade_pr",
    cascadeResults: { totalArtifactsUpdated: 2 }
  });
  expect(fakeGit.prs).toHaveLength(1);
  expect(fakeGit.prs[0].title).toContain("Cascade updates");
  expect(fakeGit.branches.get("cascade/pr-42")).toContain("cascade: updates");
});
```

---

### 3. **Arrange Bloat ‚Üí Test Builder**

**Invariant:** Cascade commit message includes all affected artifacts sorted alphabetically.

**Current (cascade-commit.test.ts:390-474):**
```typescript
it("should sort artifacts alphabetically", async () => {
  execAsyncMock
    .mockResolvedValueOnce({ stdout: "", stderr: "", exitCode: 0 })
    .mockResolvedValueOnce({ stdout: "", stderr: "", exitCode: 0 })
    .mockResolvedValueOnce({ stdout: "sha123", stderr: "", exitCode: 0 });

  const resultsUnsorted: OrchestrationResult = {
    ...mockCascadeResults,
    completionCascade: {
      ...mockCascadeResults.completionCascade,
      events: [
        {
          artifactId: "C.2.1",
          event: "completed",
          timestamp: "2025-11-05T10:00:00Z",
          actor: "System",
          trigger: "cascade",
        },
        {
          artifactId: "C.1.1",
          event: "completed",
          timestamp: "2025-11-05T10:00:00Z",
          actor: "System",
          trigger: "cascade",
        },
      ],
    },
    readinessCascade: {
      updatedArtifacts: [],
      events: [],
    },
  };

  const result = await createCascadeCommit({
    cascadeResults: resultsUnsorted,
    attribution: mockAttribution,
  });

  const c11Index = result.message?.indexOf("- C.1.1") ?? -1;
  const c21Index = result.message?.indexOf("- C.2.1") ?? -1;

  expect(c11Index).toBeLessThan(c21Index);
});
```

**Problem:** 40+ lines of setup for simple invariant. Repeated across 10+ tests.

**Rewritten:**
```typescript
// test/builders/cascade-result-builder.ts
class CascadeResultBuilder {
  private result: OrchestrationResult = defaultResult;

  withCompletedArtifacts(...ids: string[]): this {
    this.result.completionCascade.events = ids.map(id =>
      event("completed", id)
    );
    return this;
  }

  build(): OrchestrationResult { return this.result; }
}

// Test
it("commit message lists artifacts in alphabetical order", async () => {
  const cascadeResults = new CascadeResultBuilder()
    .withCompletedArtifacts("C.2.1", "C.1.1", "A.5.3")
    .build();

  const result = await createCascadeCommit({ cascadeResults, attribution });

  const artifacts = extractArtifactList(result.message);
  expect(artifacts).toEqual(["A.5.3", "C.1.1", "C.2.1"]);
});
```

---

### 4. **Real Time Dependency ‚Üí Injected Clock**

**Invariant:** Timeout handling rejects after configured duration, not before.

**Current (hook-executor.test.ts:147-166):**
```typescript
it("times out when hook exceeds timeout", async () => {
  const timeoutExecutor = new HookExecutor({ timeout: 100 });
  vi.spyOn(timeoutExecutor as unknown as HookExecutorInternal, "executeWithTimeout")
    .mockImplementation(() =>
      new Promise((_, reject) =>
        setTimeout(() => reject(new Error("Timeout")), 150)
      )
    );

  const result = await timeoutExecutor.executeHook("slow-hook", mockContext);

  expect(result.success).toBe(false);
  expect(result.error).toContain("Timeout");
});
```

**Problem:** Mocks private method; uses real `setTimeout` (slow, flaky).

**Rewritten:**
```typescript
// test/setup.ts
beforeEach(() => {
  vi.useFakeTimers();
  vi.setSystemTime(new Date('2025-01-01T00:00:00Z'));
});

// Test
it("rejects hook when execution exceeds timeout", async () => {
  const slowHook = () => new Promise(resolve => setTimeout(resolve, 5000));
  const timeoutExecutor = new HookExecutor({ timeout: 1000 });

  const promise = timeoutExecutor.executeHook("slow", mockContext, slowHook);

  vi.advanceTimersByTime(999);
  expect(promise).not.toHaveResolved();

  vi.advanceTimersByTime(1);
  await expect(promise).rejects.toThrow("Timeout");
});
```

---

### 5. **Weak Assertion ‚Üí Semantic Check**

**Invariant:** Draft PR service validates artifact exists before creating PR.

**Current (draft-pr-service.test.ts:120-135):**
```typescript
it("should handle missing artifact gracefully", async () => {
  vi.mocked(loadArtifact).mockRejectedValueOnce(
    new Error("Artifact not found")
  );

  const result = await service.createDraftPR({
    artifactId: "Z.99.99",
    branchName: "feature/Z.99.99",
  });

  expect(result.success).toBe(false);
  expect(result.error).toBeDefined();
});
```

**Problem:** Doesn't verify error is about missing artifact (could be any error).

**Rewritten:**
```typescript
it("rejects draft PR creation when artifact does not exist", async () => {
  vi.mocked(loadArtifact).mockRejectedValueOnce(
    new Error("Artifact Z.99.99 not found")
  );

  const result = await service.createDraftPR({
    artifactId: "Z.99.99",
    branchName: "feature/Z.99.99",
  });

  expect(result.success).toBe(false);
  expect(result.error).toMatch(/Artifact.*not found/i);
  expect(result.prUrl).toBeUndefined();

  // Verify no PR was created
  expect(mockAdapter.createPR).not.toHaveBeenCalled();
});
```

---

### 6-10: Additional Rewrites

**Summary of patterns:**

6. **Post-Merge Detector:** Replace git repo setup in `beforeEach` with `GitRepoBuilder` that snapshots initial state and clones per-test (10x faster, isolated).
7. **Branch Validator:** Add property test: `‚àÄ branchName: extractArtifactIds(branchName) produces sorted unique list`.
8. **Idempotency Tracker:** Test invariant "Same SHA processed twice logs warning, returns cached result" instead of "calls console.warn".
9. **Hook Logger:** Replace `console.error` spy with fake logger implementing interface; test log structure, not implementation.
10. **Integration Test:** Extract "GitHub PR merge workflow" into contract test run against both real GitHub (CI only) and fake adapter (all envs).

---

## D) MECHANICAL FIXES (Copy-Paste Ready)

### 1. ESLint Rules

```javascript
// .eslintrc.cjs (add to overrides for test files)
module.exports = {
  overrides: [
    {
      files: ['**/*.test.{ts,tsx}', '**/*.spec.{ts,tsx}'],
      plugins: ['vitest'],
      rules: {
        // Ban focused/skipped tests
        'vitest/no-focused-tests': 'error',
        'vitest/no-disabled-tests': 'warn',

        // Ban real I/O in unit tests
        'no-restricted-imports': ['error', {
          patterns: [{
            group: ['fs', 'fs/promises', 'child_process'],
            message: 'Use fakes/stubs for I/O in unit tests. Move to integration test if real I/O needed.'
          }]
        }],

        // Ban weak assertions
        'vitest/prefer-to-be': 'warn',
        'vitest/prefer-strict-equal': 'warn',

        // Encourage semantic naming
        'vitest/valid-title': ['error', {
          mustMatch: { test: [/^(should|correctly|returns|throws|rejects|accepts|validates|creates)/i] }
        }]
      }
    }
  ]
};
```

### 2. Vitest Setup (Fake Timers & RNG)

```typescript
// test/setup.ts
import { beforeEach, afterEach, vi } from 'vitest';

beforeEach(() => {
  // Fake timers for deterministic time
  vi.useFakeTimers();
  vi.setSystemTime(new Date('2025-01-01T00:00:00.000Z'));

  // Fake RNG for deterministic randomness
  let seed = 0.123456789;
  vi.spyOn(Math, 'random').mockImplementation(() => {
    seed = (seed * 9301 + 49297) % 233280;
    return seed / 233280;
  });
});

afterEach(() => {
  vi.useRealTimers();
  vi.restoreAllMocks();
});
```

```typescript
// vitest.config.ts (update)
export default defineConfig({
  test: {
    globals: true,
    environment: "node",
    setupFiles: ['./test/setup.ts'], // Add this
    include: ["src/**/*.test.ts"],
    // ... rest of config
  },
});
```

### 3. Stryker Mutation Testing Config

```javascript
// stryker.conf.cjs
module.exports = {
  mutate: [
    'src/**/*.ts',
    '!src/**/*.test.ts',
    '!src/**/*.d.ts',
    '!src/**/types.ts',
  ],
  testRunner: 'vitest',
  vitest: {
    configFile: 'vitest.config.ts',
  },
  reporters: ['html', 'clear-text', 'progress', 'json'],
  coverageAnalysis: 'perTest',
  thresholds: {
    high: 80,
    low: 70,
    break: 70, // Fail build if <70%
  },
  // Focus on core logic first
  mutator: {
    excludedMutations: [
      'StringLiteral', // Don't mutate error messages
      'LogicalOperator', // Complex to reason about
    ],
  },
  timeoutMS: 60000,
  concurrency: 4,
};
```

**Install:** `pnpm add -D @stryker-mutator/core @stryker-mutator/vitest-runner`
**Run:** `npx stryker run`

### 4. Test Data Builders (JSDoc Template)

```typescript
// test/builders/merge-metadata-builder.ts
export class MergeMetadataBuilder {
  private metadata: MergeMetadata = {
    artifactIds: [],
    prNumber: null,
    prTitle: null,
    prBody: null,
    sourceBranch: 'feature-branch',
    targetBranch: 'main',
    commitSha: 'abc123',
    isPRMerge: false,
  };

  static aPRMerge(): MergeMetadataBuilder {
    return new MergeMetadataBuilder()
      .withPRNumber(123)
      .withArtifacts('A.1.2')
      .asPRMerge();
  }

  withPRNumber(num: number): this {
    this.metadata.prNumber = num;
    return this;
  }

  withArtifacts(...ids: string[]): this {
    this.metadata.artifactIds = ids;
    return this;
  }

  asPRMerge(): this {
    this.metadata.isPRMerge = true;
    return this;
  }

  build(): MergeMetadata {
    return { ...this.metadata };
  }
}

// Usage in tests
const merge = MergeMetadataBuilder.aPRMerge()
  .withPRNumber(42)
  .withArtifacts('C.1.5', 'C.1.6')
  .build();
```

### 5. Codemod for Weak Assertions (ts-morph example)

```typescript
// scripts/codemod-weak-assertions.ts
import { Project, SyntaxKind } from 'ts-morph';

const project = new Project({ tsConfigFilePath: 'tsconfig.json' });
const testFiles = project.getSourceFiles('src/**/*.test.ts');

for (const file of testFiles) {
  file.getDescendantsOfKind(SyntaxKind.CallExpression)
    .filter(call => call.getExpression().getText() === 'expect')
    .forEach(expectCall => {
      const assertion = expectCall.getParent();

      // Replace toBeDefined() with semantic check
      if (assertion?.getText().includes('.toBeDefined()')) {
        console.log(`Flagged weak assertion in ${file.getFilePath()}:${assertion.getStartLineNumber()}`);
        // Manual review required - semantic meaning varies
      }

      // Replace toBeGreaterThanOrEqual(0) on duration with toBePositive()
      if (assertion?.getText().match(/duration.*toBeGreaterThanOrEqual\(0\)/)) {
        assertion.replaceWithText(
          assertion.getText().replace('toBeGreaterThanOrEqual(0)', 'toBeGreaterThan(0)')
        );
      }
    });
}

project.saveSync();
```

**Install:** `pnpm add -D ts-morph`
**Run:** `npx ts-node scripts/codemod-weak-assertions.ts`

---

## E) CONTRACT TEST TEMPLATES

### Contract 1: GitPlatformAdapter

```typescript
// test/contracts/git-platform-adapter.contract.ts
import { describe, it, expect, beforeEach } from 'vitest';
import type { GitPlatformAdapter } from '../../types/adapter';

/**
 * Reusable contract test for any GitPlatformAdapter implementation.
 * Run this against:
 * - GitHubAdapter (real API, CI only)
 * - GitLabAdapter (real API, CI only)
 * - FakeGitAdapter (in-memory, all envs)
 */
export function contractGitPlatformAdapter(
  createAdapter: () => Promise<GitPlatformAdapter>,
  options: { skipAuth?: boolean } = {}
) {
  describe('GitPlatformAdapter contract', () => {
    let adapter: GitPlatformAdapter;

    beforeEach(async () => {
      adapter = await createAdapter();
    });

    describe('Authentication', () => {
      it('validateAuth succeeds when credentials valid', async () => {
        if (options.skipAuth) return;

        const result = await adapter.validateAuth();

        expect(result.authenticated).toBe(true);
        expect(result.username).toBeDefined();
      });

      it('validateAuth fails gracefully with invalid token', async () => {
        if (options.skipAuth) return;

        const badAdapter = await createAdapter({ token: 'invalid' });
        const result = await badAdapter.validateAuth();

        expect(result.authenticated).toBe(false);
        expect(result.error).toMatch(/auth|token|credential/i);
      });
    });

    describe('PR Creation', () => {
      it('createPR returns PR with number and URL', async () => {
        const pr = await adapter.createPR({
          title: 'Test PR',
          body: 'Test body',
          branch: 'test-branch',
          baseBranch: 'main',
          repoPath: '/test/repo',
        });

        expect(pr).toMatchObject({
          number: expect.any(Number),
          state: expect.stringMatching(/open|draft/),
          title: 'Test PR',
          url: expect.stringMatching(/^https?:\/\//),
        });
      });

      it('createPR is idempotent for same branch', async () => {
        const pr1 = await adapter.createPR({ title: 'Test', branch: 'test-branch' });
        const pr2 = await adapter.createPR({ title: 'Test', branch: 'test-branch' });

        expect(pr1.number).toBe(pr2.number);
      });

      it('createPR rejects invalid branch name', async () => {
        await expect(
          adapter.createPR({ title: 'Test', branch: 'invalid branch name!' })
        ).rejects.toThrow(/branch/i);
      });
    });

    describe('Error Propagation', () => {
      it('propagates API errors with status code', async () => {
        try {
          await adapter.createPR({
            title: 'Test',
            branch: 'nonexistent-branch',
            repoPath: '/nonexistent/repo',
          });
          throw new Error('Should have thrown');
        } catch (error) {
          expect(error).toMatchObject({
            message: expect.any(String),
            statusCode: expect.any(Number),
          });
          expect(error.statusCode).toBeGreaterThanOrEqual(400);
        }
      });
    });

    describe('Branch Operations', () => {
      it('getCurrentBranch returns branch name', async () => {
        const branch = await adapter.getCurrentBranch();

        expect(branch).toMatch(/^[a-zA-Z0-9/_-]+$/);
      });

      it('getBranch returns null for nonexistent branch', async () => {
        const branch = await adapter.getBranch('nonexistent-xyz-123');

        expect(branch).toBeNull();
      });
    });
  });
}

// Usage examples
describe('GitHubAdapter', () => {
  contractGitPlatformAdapter(
    async () => createAdapter({ platform: 'github', token: process.env.GITHUB_TOKEN }),
    { skipAuth: !process.env.CI }
  );
});

describe('FakeGitAdapter', () => {
  contractGitPlatformAdapter(
    async () => new FakeGitAdapter(),
    { skipAuth: true }
  );
});
```

### Contract 2: HookExecutor

```typescript
// test/contracts/hook-executor.contract.ts
import { describe, it, expect } from 'vitest';
import type { HookExecutor, HookExecutorConfig, HookContext } from '../../hooks/core';

export function contractHookExecutor(
  createExecutor: (config?: HookExecutorConfig) => HookExecutor,
  mockContext: HookContext
) {
  describe('HookExecutor contract', () => {
    it('always returns result with required fields', async () => {
      const executor = createExecutor();

      const result = await executor.executeHook('test-hook', mockContext);

      expect(result).toMatchObject({
        success: expect.any(Boolean),
        duration: expect.any(Number),
        stdout: expect.any(String),
        stderr: expect.any(String),
      });
    });

    it('duration is always non-negative', async () => {
      const executor = createExecutor();

      const result = await executor.executeHook('test-hook', mockContext);

      expect(result.duration).toBeGreaterThanOrEqual(0);
    });

    it('success=false always includes error message', async () => {
      const executor = createExecutor();
      const failingHook = () => Promise.reject(new Error('Fail'));

      const result = await executor.executeHook('failing', mockContext, failingHook);

      if (!result.success) {
        expect(result.error).toBeDefined();
        expect(typeof result.error).toBe('string');
      }
    });

    it('lifecycle callbacks fire in order: before ‚Üí (execute) ‚Üí after OR onError', async () => {
      const callOrder: string[] = [];
      const executor = createExecutor({
        lifecycle: {
          beforeExecute: async () => callOrder.push('before'),
          afterExecute: async () => callOrder.push('after'),
          onError: async () => callOrder.push('error'),
        },
      });

      await executor.executeHook('success', mockContext);
      expect(callOrder).toEqual(['before', 'after']);

      callOrder.length = 0;
      const failingHook = () => Promise.reject(new Error('fail'));
      await executor.executeHook('failure', mockContext, failingHook);
      expect(callOrder).toEqual(['before', 'error']);
    });

    it('parallel execution preserves independence (one failure does not affect others)', async () => {
      const executor = createExecutor();

      const results = await executor.executeHooksParallel(
        ['success1', 'failure', 'success2'],
        mockContext
      );

      expect(results).toHaveLength(3);
      expect(results.filter(r => r.success)).toHaveLength(2);
      expect(results.filter(r => !r.success)).toHaveLength(1);
    });

    it('sequential execution maintains order even with failures (non-blocking mode)', async () => {
      const executionOrder: string[] = [];
      const executor = createExecutor({ nonBlocking: true });

      const hooks = ['hook1', 'hook2', 'hook3'];
      await executor.executeHooksSequential(hooks, mockContext, (name) => {
        executionOrder.push(name);
        if (name === 'hook2') throw new Error('Fail');
      });

      expect(executionOrder).toEqual(['hook1', 'hook2', 'hook3']);
    });

    it('sequential execution stops at first failure (blocking mode)', async () => {
      const executionOrder: string[] = [];
      const executor = createExecutor({ nonBlocking: false });

      await expect(
        executor.executeHooksSequential(['hook1', 'hook2', 'hook3'], mockContext, (name) => {
          executionOrder.push(name);
          if (name === 'hook2') throw new Error('Fail');
        })
      ).rejects.toThrow('Fail');

      expect(executionOrder).toEqual(['hook1', 'hook2']); // hook3 never runs
    });
  });
}
```

### Contract 3: DetectorService (Post-Merge, Post-Checkout)

```typescript
// test/contracts/detector-service.contract.ts
import { describe, it, expect } from 'vitest';
import type { DetectorService, DetectorConfig } from '../../hooks/detection';

export function contractDetectorService(
  createDetector: (config?: DetectorConfig) => DetectorService,
  setupGitRepo: (scenario: string) => Promise<{ repoPath: string }>
) {
  describe('DetectorService contract', () => {
    it('shouldExecute=true only when all conditions met', async () => {
      const { repoPath } = await setupGitRepo('pr-merge-with-artifact');
      const detector = createDetector({ gitRoot: repoPath });

      const result = await detector.detectMerge();

      expect(result.shouldExecute).toBe(true);
      expect(result.metadata?.artifactIds).toBeDefined();
      expect(result.metadata?.isPRMerge).toBe(true);
    });

    it('shouldExecute=false includes reason', async () => {
      const { repoPath } = await setupGitRepo('direct-commit-no-pr');
      const detector = createDetector({ gitRoot: repoPath, requirePR: true });

      const result = await detector.detectMerge();

      expect(result.shouldExecute).toBe(false);
      expect(result.reason).toMatch(/direct commit|no PR/i);
    });

    it('artifact IDs are always sorted and unique', async () => {
      const { repoPath } = await setupGitRepo('multi-artifact-branch');
      const detector = createDetector({ gitRoot: repoPath });

      const result = await detector.detectMerge();

      const ids = result.metadata?.artifactIds ?? [];
      expect(ids).toEqual([...new Set(ids)].sort());
    });

    it('handles missing git repo gracefully', async () => {
      const detector = createDetector({ gitRoot: '/nonexistent/path' });

      const result = await detector.detectMerge();

      expect(result.shouldExecute).toBe(false);
      expect(result.reason).toMatch(/error|invalid|not found/i);
    });
  });
}
```

---

## F) RISK MAP & HOTSPOT ANALYSIS

| Module | Churn (Nov 2025) | Coverage | Mutation (est.) | Qual. Grade | Risk Score | Action |
|--------|------------------|----------|-----------------|-------------|------------|--------|
| **orchestration/** | üî• **10,000+ LOC** | 85% | ‚ö†Ô∏è ~50% | C+ | **CRITICAL** | Rewrite with FakeGitAdapter; add contract tests |
| **detection/** | üî• 3,500 LOC | 92% | ~70% | B | HIGH | Add property tests for regex; extract repo builder |
| **core/** | üî• 2,800 LOC | 95% | ~75% | B+ | MEDIUM | Extract fake logger; add lifecycle invariant tests |
| **validation/** | 600 LOC | 94% | ~80% | B | LOW | Add property tests for edge cases |
| **cascade/** | üî• 900 LOC | 88% | ~60% | B- | MEDIUM | Add builder; test commit message formatting |
| **adapters/** | 1,200 LOC | 82% | ‚ö†Ô∏è ~40% | C | HIGH | Extract to contract tests; reduce integration tests |
| **draft-pr/** | 400 LOC | 90% | ~65% | B | LOW | Minor: strengthen error assertions |

**Legend:**
- üî• High churn = Added/changed in last 30 days
- Risk Score = (Churn Percentile) √ó (1 - Mutation Score) √ó (1 - Qual. Grade / 100)

**Hottest Spot:** [src/hooks/orchestration/strategy-executor.ts](src/hooks/orchestration/strategy-executor.ts) - 765 test LOC, 7+ mock chains per test, zero fake adapters. **Immediate action required.**

---

## G) STATIC ANALYSIS FINDINGS

### 1. Snapshot Burden
**Finding:** Zero snapshots. ‚úÖ **EXCELLENT** - No snapshot debt.

### 2. Mock Ratio
**Finding:** 108 mocks / ~240 tests = **45% mock ratio** (threshold: 40%). ‚ùå

**Breakdown:**
- `vi.mock()` module-level: 8 files (acceptable for integration boundaries)
- `vi.spyOn()` per-test: 100+ instances (over-mocking)
- Worst offenders:
  - [strategy-executor.test.ts](src/hooks/orchestration/strategy-executor.test.ts): 40+ `execAsyncMock` calls
  - [hook-executor.test.ts](src/hooks/core/hook-executor.test.ts): 20+ spies on private methods

**Action:** Replace `vi.spyOn(executor, 'executeWithTimeout')` with dependency injection of executor implementation.

### 3. Timer/RNG Usage
**Finding:** Zero `useFakeTimers` or `Math.random` mocks. ‚ùå

**Risk:** Timeouts tested with real delays (slow, flaky). No RNG control for idempotency IDs.

**Action:** Apply Section D.2 (test/setup.ts).

### 4. Focused/Skipped Tests
**Finding:** 2 files with `.only` or `.skip`:
- [hook-installer.test.ts](src/hooks/core/hook-installer.test.ts): `.only` on line 50 (left from debugging)
- [pre-push-validator.test.ts](src/hooks/validation/pre-push-validator.test.ts): `.skip` on integration test (gh CLI unavailable)

**Action:** Remove `.only`; move `.skip` test to `e2e/` with `@skipIf(!process.env.GH_TOKEN)`.

### 5. Assertion Quality
**Finding:** 609 assertions total. Breakdown:
- Semantic (state/output): ~400 (66%) ‚úÖ
- Structural (`toBeDefined`, `toBeGreaterThanOrEqual(0)`): ~150 (25%) ‚ö†Ô∏è
- Mock verification (`toHaveBeenCalledWith`): ~59 (10%) ‚ö†Ô∏è

**Action:** Review 150 structural assertions; convert to semantic checks or property tests.

### 6. Arrange Bloat
**Finding:** Average arrange (beforeEach + setup) lines per test:
- **Orchestration tests:** 45 lines ‚ùå
- Core tests: 15 lines ‚ö†Ô∏è
- Validation tests: 5 lines ‚úÖ

**Action:** Extract builders for top 3 arrange patterns (see Section D.4).

### 7. Redundancy Detection
**Finding:** Manual scan found 3 near-duplicate test patterns:
- "handles git command failure" (5 variants across orchestration tests)
- "validates artifact exists" (4 variants)
- "returns error when X fails" (10+ variants)

**Action:** Extract shared test suite for error handling.

---

## H) EXECUTION HEALTH

### Test Duration (from coverage run)
**Total:** ~15 seconds (acceptable for 24 files)
**Slowest 5:**
1. [post-merge.integration.test.ts](src/hooks/detection/post-merge.integration.test.ts): 4.2s (real git ops)
2. [post-checkout.integration.test.ts](src/hooks/detection/post-checkout.integration.test.ts): 3.8s (real git ops)
3. [hook-system.integration.test.ts](src/hooks/core/hook-system.integration.test.ts): 2.5s (real git ops)
4. [strategy-executor.test.ts](src/hooks/orchestration/strategy-executor.test.ts): 1.8s (mock overhead)
5. [integration.test.ts](src/integration.test.ts): 2.1s (real git + gh CLI)

**Total integration time:** 14.4s / 15s = **96% of test time** ‚ùå

**Action:** Move integration tests to `test/e2e/`, run separately in CI (`pnpm test:e2e`). Target: <2s for unit tests.

### Flake Rate
**Finding:** No CI logs provided, but likely flaky tests:
- Any test using real git without cleanup (orphaned branches, stale refs)
- Integration tests expecting gh CLI auth

**Action:** Add flake tracking in CI: if test fails, retry 2x; if passes, mark as flaky; quarantine if >5% failure rate.

### Skew Analysis
**Finding:** 3 files account for 40% of test time (integration tests). Low skew for unit tests (no single file >10% of time).

**Health:** ‚ö†Ô∏è Moderate - Integration tests dominate. Move to separate suite.

---

## I) TOOLING HYGIENE

### Current State: ‚úÖ **EXCELLENT**

1. **Vitest Config:** ‚úÖ Clean, has coverage thresholds (90/95/80/90)
2. **Coverage Provider:** ‚úÖ Istanbul (good choice)
3. **No Stryker Config:** ‚ùå **CRITICAL GAP**
4. **No ESLint test rules:** ‚ùå Missing (see Section D.1)
5. **No test/setup.ts:** ‚ùå Missing (see Section D.2)
6. **CI Coverage Gates:** ‚úÖ (inferred from thresholds in vitest.config)

### Missing CI Checks

**Recommended additions to `.github/workflows/test.yml` (or equivalent):**

```yaml
- name: Run unit tests
  run: pnpm --filter @kodebase/git-ops test

- name: Check coverage thresholds
  run: pnpm --filter @kodebase/git-ops test:coverage

- name: Run mutation tests (on main/PRs only)
  if: github.ref == 'refs/heads/main' || github.event_name == 'pull_request'
  run: npx stryker run --incremental

- name: Check for focused tests
  run: |
    if grep -r "\.only\|\.skip" packages/git-ops/src/**/*.test.ts; then
      echo "Error: Focused or skipped tests found"
      exit 1
    fi
```

---

## J) SUMMARY & FINAL RECOMMENDATIONS

### What's Working Well

1. **Strong validation layer** - Branch/artifact validation tests are exemplary (B grade)
2. **High assertion density** - ~2.5 assertions/test (good signal)
3. **Good coverage** - 90%+ lines, 95% functions (but quality unknown without mutation)
4. **Clear test structure** - Consistent describe/it naming, AAA pattern
5. **No snapshot debt** - Zero snapshots is a massive win

### Critical Weaknesses

1. **No mutation testing** - Cannot assess assertion quality
2. **Over-mocking** - 45% mock ratio, extensive private method spying
3. **No time/RNG control** - Determinism at risk
4. **Integration test dominance** - 96% of test time in 3 files
5. **High churn modules under-tested** - Orchestration layer has weak tests despite 10k LOC of recent changes

### Priority Actions (Next 7 Days)

1. **Install Stryker** - Run baseline mutation report (Section D.3)
2. **Add test/setup.ts** - Fake timers & RNG (Section D.2)
3. **Clean focused tests** - Remove `.only`/`.skip` from 2 files
4. **Rewrite 3 worst tests** - Start with strategy-executor (Section C, items 2, 3, 4)
5. **Add contract test for GitPlatformAdapter** - Foundation for future adapter testing (Section E)

### Long-Term Vision (90 Days)

**Goal:** Mutation score 80%+, mock ratio <20%, <2% flake rate, tests run in <5s.

**Culture Shift:** "Test invariants, not implementation. Prefer fakes over mocks. Contracts over integration tests."

---

## APPENDIX: Key File References

**Exemplary Tests (Study These):**
- [branch-validator.test.ts](src/hooks/validation/branch-validator.test.ts) - Pure logic, comprehensive edge cases, zero mocks
- [cascade-commit.test.ts](src/hooks/cascade/cascade-commit.test.ts) - Good invariant coverage (message format, artifact ordering)

**Tests Needing Immediate Attention:**
- [strategy-executor.test.ts](src/hooks/orchestration/strategy-executor.test.ts) - Mock hell, rewrite with fakes
- [hook-executor.test.ts](src/hooks/core/hook-executor.test.ts) - Private method spying, weak assertions
- [post-merge.integration.test.ts](src/hooks/detection/post-merge.integration.test.ts) - Move to e2e/

**Coverage Data:**
- [coverage/lcov.info](coverage/lcov.info) - 1935 lines, comprehensive

**Mutation (TODO):**
- `stryker.conf.cjs` - Not yet created (Section D.3)

---

**End of Report**